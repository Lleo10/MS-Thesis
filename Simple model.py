# -*- coding: utf-8 -*-
"""polymer langevin

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WX-w0H42XdK4zvqmSg8dkiMxoOYemfO7
"""

import random
import numpy as np
import matplotlib.pyplot as plt 
import math
from tqdm import tqdm as tqdm
from numba import njit


#Parameters

N   = 500
rho = 0.1     #density
kB_T   = 1
dt = 0.001
zeta = 1
kappa = 1000
kappa_dp = 100
kappa_dd = 100
kappa_anchor = 1000
lb = 1
lb_d = 1
rc2 = np.cbrt(2)
frequency = 5000
timesteps = 500000
flowx = 0
flowy = 0
flowz = 0



def intialize_pos(x,y,z,N):
  for i in range(N):
    x[i] = i*lb
    y[i] = 0.0
    z[i] = 0.0
  return x,y,z


def intialize_vel(Vx,Vy,Vz,N):
  KE_temp=0

  for i in range(N):
    Vx[i]=random.random()-0.5
    Vy[i]=random.random()-0.5
    Vz[i]=random.random()-0.5
    KE_temp = KE_temp +  (1/2)*(Vx[i]**2+Vy[i]**2+Vz[i]**2)

  Vx_sum=sum(Vx)
  Vy_sum=sum(Vy)
  Vz_sum=sum(Vz)

  for i in range(N):
    Vx[i]=Vx[i]-(Vx_sum/N)
    Vy[i]=Vy[i]-(Vy_sum/N)
    Vz[i]=Vz[i]-(Vz_sum/N)

  for i in range(N):
    Vx[i]=(math.sqrt((3*N*kB_T)/(2*KE_temp)))*Vx[i]
    Vy[i]=(math.sqrt((3*N*kB_T)/(2*KE_temp)))*Vy[i]
    Vz[i]=(math.sqrt((3*N*kB_T)/(2*KE_temp)))*Vz[i]
  return Vx, Vy, Vz

def Kinetic_E(Vx,Vy,Vz):
  KE=0
  for i in range(N):
    KE+=(1/2)*((Vx[i]**2)+(Vy[i]**2)+(Vz[i]**2))
  return KE

@njit
def force(fx,fy,fz,x,y,z,rc2): 
  ulj=0
  for i in range(N):
    fx[i]=0
    fy[i]=0
    fz[i]=0

  for i in range(N-1):
    j = (i+1)
    dx = x[i]-x[j]
    dy = y[i]-y[j]
    dz = z[i]-z[j]

    dr2 = dx**2 + dy**2 + dz**2
    dr  = math.sqrt(dr2)
    ulj   = ulj+(dr-lb)**2
    f   = kappa*(1-lb/dr)   #F_stretch
    
    Fx = -f*dx
    Fy = -f*dy 
    Fz = -f*dz

    fx[i] += Fx
    fy[i] += Fy
    fz[i] += Fz

    fx[j] -= Fx
    fy[j] -= Fy
    fz[j] -= Fz

  ulj = ulj*kappa/2   

  #Ulj
  for i in range(N-1):
    for j in range(i+1,N):
        x_diff_n=x[i]-x[j]
        y_diff_n=y[i]-y[j]
        z_diff_n=z[i]-z[j]

        r2=((x_diff_n**2)+(y_diff_n**2)+(z_diff_n**2))

        if(r2 < rc2 and r2!=0 and j != i+1 and j != i-1):
          force=48*(((1/r2)**7)-((1/2)*((1/r2)**4)))          #F_LJ
          fox= force*x_diff_n 
          foy= force*y_diff_n 
          foz= force*z_diff_n 

          r6 = r2**3
          rc6=rc2**3
          ulj += 4*(1/r6)*(1/r6 - 1.0)-(4*(1/rc6)*(1/rc6 - 1.0))
          #print("passed")
        else:
          fox=0
          foy=0
          foz=0


        fx[i] = fx[i] + fox
        fx[j] = fx[j] - fox
            
            
        fy[i] = fy[i] + foy
        fy[j] = fy[j] - foy
            
            
        fz[i] = fz[i] + foz
        fz[j] = fz[j] - foz
        

  return fx,fy,fz,ulj

def update_position(x,y,z,N,dt):
  for i in range(N):
    x[i]=x[i]+Vx[i]*C
    y[i]=y[i]+Vy[i]*C
    z[i]=z[i]+Vz[i]*C

  return x,y,z

def update_velocities(Vx,Vy,Vz,N,dt,A,zeta,eta1,eta2,eta3):
  for i in range(N):
    Vx[i]=A*Vx[i]+fx[i]*dt*(1/2)+B*eta1[i]
    Vy[i]=A*Vy[i]+fy[i]*dt*(1/2)+B*eta2[i]
    Vz[i]=A*Vz[i]+fz[i]*dt*(1/2)+B*eta3[i]
  return Vx,Vy,Vz

def distance(N):
  r2 = 0
  dx = x[0]-x[N-1]
  dy = y[0]-y[N-1]
  dz = z[0]-z[N-1]
  r2 = dx**2 + dy**2 + dz**2
  dist = np.sqrt(r2)
  return dist

def ROG():
  Rcm_x=0
  Rcm_y=0
  Rcm_z=0
  Rg2=0
  for i in range(N):
    Rcm_x = Rcm_x + x[i]
    Rcm_y = Rcm_y + y[i]
    Rcm_z = Rcm_z + z[i]
  Rcm_x = Rcm_x/N
  Rcm_y = Rcm_y/N
  Rcm_z = Rcm_z/N
  for i in range(N):
    dx = x[i]-Rcm_x
    dy = y[i]-Rcm_y
    dz = z[i]-Rcm_z 

    dr2 = dx**2 + dy**2 + dz**2
    Rg2 +=dr2
  Rg2 = Rg2/N  
  return Rg2

"""DIMER CODE"""

#Initialise dimer (check where to place (on polymer directly) or (far from polymer, snaps onto polymer))
def intialize_dimer(xd,yd,zd):
  for i in range(2):
    xd[i] = x[selected_mono1+i]
    yd[i] = y[selected_mono1+i]
    zd[i] = z[selected_mono1+i]
  return xd,yd,zd

def force_dimer(fxd,fyd,fzd,xd,yd,zd,rc2): 

  uljd=0
  for i in range(2):
    fxd[i]=0
    fyd[i]=0
    fzd[i]=0

#force between 2 monomers of dimer(cohesin)
  dxd = xd[0]-xd[1]
  dyd = yd[0]-yd[1]
  dzd = zd[0]-zd[1]

  dr2_d = dxd**2 + dyd**2 + dzd**2
  dr_d  = math.sqrt(dr2_d)
  uljd   = uljd+(dr_d-lb_d)**2
  f_d   = kappa_dd*(1-lb_d/dr_d)   #F_stretch
  
  Fx_d = -f_d*dxd
  Fy_d = -f_d*dyd 
  Fz_d = -f_d*dzd

  fxd[0] += Fx_d
  fyd[0] += Fy_d
  fzd[0] += Fz_d

  fxd[1] -= Fx_d
  fyd[1] -= Fy_d
  fzd[1] -= Fz_d

  uljd = uljd*kappa/2

#force between dimer and polymer
#FOR 1
  dx_dp1 = x[selected_mono1]-xd[0]
  dy_dp1 = y[selected_mono1]-yd[0]
  dz_dp1 = z[selected_mono1]-zd[0]

  dr2_dp1 = dx_dp1**2 + dy_dp1**2 + dz_dp1**2
  dr_dp1  = math.sqrt(dr2_dp1)
  uljd   = uljd+(dr_dp1-(0))**2
  f_dp   = kappa_dp*(1-(0))   
  #(dr_dp would be zero, sort that out)
    
  Fx_dp1 = -f_dp*dx_dp1
  Fy_dp1 = -f_dp*dy_dp1
  Fz_dp1 = -f_dp*dz_dp1
    
  fxd[0] -= Fx_dp1
  fyd[0] -= Fy_dp1
  fzd[0] -= Fz_dp1
    
  fx[selected_mono1] += Fx_dp1
  fy[selected_mono1] += Fy_dp1
  fz[selected_mono1] += Fz_dp1
  
  dr_dp1_arr.append(dr_dp1)
  
  
  #FOR 2
  dx_dp2 = x[selected_mono2]-xd[1]
  dy_dp2 = y[selected_mono2]-yd[1]
  dz_dp2 = z[selected_mono2]-zd[1]

  dr2_dp2 = dx_dp2**2 + dy_dp2**2 + dz_dp2**2
  dr_dp2  = math.sqrt(dr2_dp2)
  uljd   = uljd+(dr_dp2-(0))**2
  f_dp   = kappa_dp*(1-(0))   
  #(dr_dp would be zero, sort that out)
    
  Fx_dp2 = -f_dp*dx_dp2
  Fy_dp2 = -f_dp*dy_dp2
  Fz_dp2 = -f_dp*dz_dp2
    
  fxd[1] -= Fx_dp2
  fyd[1] -= Fy_dp2
  fzd[1] -= Fz_dp2
    
  fx[selected_mono2] += Fx_dp2
  fy[selected_mono2] += Fy_dp2
  fz[selected_mono2] += Fz_dp2
  
  dr_dp2_arr.append(dr_dp2)
    

  uljd = uljd*kappa_dp/2

  return fxd,fyd,fzd,uljd

def update_position_dimer(xd,yd,zd,dt):
  for i in range(2):
    xd[i]=xd[i]+Vxd[i]*dt+fxd[i]*dt*dt*(1/2)
    yd[i]=yd[i]+Vyd[i]*dt+fyd[i]*dt*dt*(1/2)
    zd[i]=zd[i]+Vzd[i]*dt+fzd[i]*dt*dt*(1/2)
  return xd,yd,zd

def update_velocities_dimer(Vxd,Vyd,Vzd,fxd,fyd,fzd,dt):
  for i in range(2):
    Vxd[i]=Vxd[i]+fxd[i]*dt*(1/2)
    Vyd[i]=Vyd[i]+fyd[i]*dt*(1/2)
    Vzd[i]=Vzd[i]+fzd[i]*dt*(1/2)
  return Vxd,Vyd,Vzd

"""END DIMER CODE"""


''' ANCHOR CODE'''

def intialize_anchor(xa,ya,za):
  for i in range(2):
    xa[i] = x[499*i]
    ya[i] = y[499*i]
    za[i] = z[499*i]
  return xa,ya,za


'''END ANCHOR CODE'''
  


dist_arr1 = []
KE_arr1 = []
PE_arr1 = []
PED_arr1 = []
PE_total_arr1 = []
RG_arr1 = []
dr_dp1_arr = []
dr_dp2_arr = []

selected_mono1_arr = []
selected_mono2_arr = []

dimer1_distance_arr = []
dimer2_distance_arr = []

position_arr = []
positiond_arr = []
frames = []



time=np.linspace(0,20,20000)

x   = [0.0]*N
y   = [0.0]*N
z   = [0.0]*N

Vx  = [0.0]*N
Vy  = [0.0]*N
Vz  = [0.0]*N

fx  = [0.0]*N
fy  = [0.0]*N
fz  = [0.0]*N

x2  = [0.0]*N
y2  = [0.0]*N
z2  = [0.0]*N

 #For Dimer
xd   = [0.0]*2
yd   = [0.0]*2
zd   = [0.0]*2

Vxd  = [0.0]*2
Vyd  = [0.0]*2
Vzd  = [0.0]*2

fxd  = [0.0]*2
fyd  = [0.0]*2
fzd  = [0.0]*2
  #End
  
  #For Anchor
xa = [0.0]*2
ya = [0.0]*2
za = [0.0]*2


selected_mono1 = random.randint(200, N-200)
selected_mono2 = selected_mono1 + 1
A=(2-zeta*dt)/(2+zeta*dt)
B=math.sqrt(kB_T*zeta*dt/2)
C=2*dt/(2+zeta*dt)
 
x,y,z=intialize_pos(x,y,z,N)
 #Saving initial positions 
x2=np.copy(x)
y2=np.copy(y)
z2=np.copy(z)
Vx,Vy,Vz=intialize_vel(Vx,Vy,Vz,N)
fx,fy,fz,en= force(fx,fy,fz,x,y,z,rc2)

xd,yd,zd = intialize_dimer(xd,yd,zd)
fxd,fyd,fzd,en_d = force_dimer(fxd,fyd,fzd,xd,yd,zd,rc2)

xa,ya,za = intialize_anchor(xa,ya,za)
  


for i in tqdm(range(timesteps)):
    if(i>10000):
        if(selected_mono1 >= 50 and selected_mono2 <= 450):
            if(i%frequency==0 and i!=0):
                if(random.random()<=0.5):
                    selected_mono1 = selected_mono1 - 1
                else:
                    selected_mono2 = selected_mono2 + 1
                
    selected_mono1_arr.append(selected_mono1)
    selected_mono2_arr.append(selected_mono2)
    
    loop_x = x[selected_mono1:selected_mono2+1]
    loop_y = y[selected_mono1:selected_mono2+1]
    loop_z = z[selected_mono1:selected_mono2+1]
      
      
    if(i==0):
        fig = plt.figure(figsize=(20,10))  
        ax = fig.add_subplot(111, projection='3d')
        ax.set_xlim3d(-1, 501)
        ax.set_ylim3d(-5, 5)
        ax.set_zlim3d(-5, 5)
            
        ax.plot(x,y,z, color='black')
        ax.scatter(x[selected_mono1],y[selected_mono1],z[selected_mono1], color='blue')
        ax.scatter(x[selected_mono2],y[selected_mono2],z[selected_mono2], color='blue')
        ax.plot(xd,yd,zd, color='red')
        ax.scatter(xd[0],yd[0],zd[0], color='red')
        ax.scatter(xd[1],yd[1],zd[1], color='red')
      #  ax.plot(loop_x,loop_y,loop_z, color='green')
        print('dimer 1 = ',xd[0],yd[0],zd[0])
        print('mono 1 = ',x[selected_mono1],y[selected_mono1],z[selected_mono1])
        print('selected mono -1 = ',x[selected_mono1-1],y[selected_mono1-1],z[selected_mono1-1])
        print('dimer 2 = ',xd[1],yd[1],zd[1])
        print('mono 2 = ',x[selected_mono1+1],y[selected_mono1+1],z[selected_mono1+1])
        print('selected mono +2 = ',x[selected_mono1+2],y[selected_mono1+2],z[selected_mono1+2])
        plt.show()
      
    eta1=np.random.normal(0,1,N)  #for random force (brownian motion)
    eta2=np.random.normal(0,1,N)
    eta3=np.random.normal(0,1,N)
    Vx,Vy,Vz = update_velocities(Vx,Vy,Vz,N,dt,1,zeta,eta1,eta2,eta3)
    x,y,z = update_position(x,y,z,N,dt)
    fx,fy,fz,en= force(fx,fy,fz,x,y,z,rc2)
    Vx,Vy,Vz = update_velocities(Vx,Vy,Vz,N,dt,A,zeta,eta1,eta2,eta3)
      
    xd,yd,zd = update_position_dimer(xd,yd,zd,dt)
    Vxd,Vyd,Vzd = update_velocities_dimer(Vxd,Vyd,Vzd,fxd,fyd,fzd,dt)
    fxd,fyd,fzd,en_d= force_dimer(fxd,fyd,fzd,xd,yd,zd,rc2)
    Vxd,Vyd,Vzd = update_velocities_dimer(Vxd,Vyd,Vzd,fxd,fyd,fzd,dt)
    
    dimer1_distance_x = x[selected_mono1] - xd[0]
    dimer1_distance_y = y[selected_mono1] - yd[0]
    dimer1_distance_z = z[selected_mono1] - zd[0]
      
    dimer2_distance_x = x[selected_mono2] - xd[1]
    dimer2_distance_y = y[selected_mono2] - yd[1]
    dimer2_distance_z = z[selected_mono2] - zd[1]
    
    dimer1_distance = np.sqrt(dimer1_distance_x**2 + dimer1_distance_y**2 + dimer1_distance_z**2)
    dimer2_distance = np.sqrt(dimer2_distance_x**2 + dimer2_distance_y**2 + dimer2_distance_z**2)
    
    dimer1_distance_arr.append(dimer1_distance)
    dimer2_distance_arr.append(dimer2_distance)
    
    
    if(i%(frequency/2)==0):
        combined_position_arr = []
        for j in range(len(x)):
            if(j>=selected_mono1 and j<=selected_mono2):
                combined_position_arr.append(['G',x[j],y[j],z[j]])
            else:
                combined_position_arr.append(['R',x[j],y[j],z[j]])
        for l in range(len(xd)):
            combined_position_arr.append(['B',xd[l],yd[l],zd[l]])
        frames.append(combined_position_arr)
      
    KE=Kinetic_E(Vx,Vy,Vz)
    PE_total_arr1.append((en + en_d)/(N+2))
    PE_arr1.append((en)/(N))
    PED_arr1.append((en_d)/(2))
    KE_arr1.append(KE/N)
    dist=distance(N)
    dist_arr1.append(dist)
    RG=ROG()
    RG_arr1.append(RG)
    
 

msd_arr1_avg = np.average(dist_arr1)

RG_arr1_avg=np.average(RG_arr1)

TE_arr1 =np.add(PE_total_arr1,KE_arr1)

np.savetxt('Langevin_KE.csv', KE_arr1, delimiter=',')
np.savetxt('Langevin_PE.csv', PE_arr1, delimiter=',')
np.savetxt('Langevin_PED.csv', PED_arr1, delimiter=',')
np.savetxt('Langevin_PE_total.csv', PE_total_arr1, delimiter=',')
np.savetxt('Langevin_TE.csv', TE_arr1, delimiter=',')
np.savetxt('Langevin_DIST.csv', dist_arr1, delimiter=',')
np.savetxt('dr_dp1.csv', dr_dp1_arr, delimiter=',')
np.savetxt('dr_dp2.csv', dr_dp2_arr, delimiter=',')
#np.savetxt('frames.csv', frames, delimiter='///')
#path = r'D:\Study Material\MS Thesis\Code\Langevin Polymer\SPYDER\frames.csv'
#DF = pd.DataFrame(frames)
#DF.to_csv(path)

new_path = r'D:\Study Material\College\MS Thesis\Code\Langevin Polymer\SPYDER\UNDERDAMPED\Latest\dt3_dd100_freq5000_loopcolour.xyz'

file = open(new_path, 'w')
for i in range(len(frames)):
    file.write("502\n")
    file.write(str(i+1)+"\n")
    for j in range(502):
        file.write("{:4} {:11.6f} {:11.6f} {:11.6f}\n".format(
            frames[i][j][0], frames[i][j][1],
            frames[i][j][2], frames[i][j][3]))



plt.plot(selected_mono1_arr, color='red', label='selected mono 1')
plt.xlabel('steps')
plt.xlim(0,timesteps)
plt.legend()
#plt.show()

plt.plot(selected_mono2_arr, color='magenta', label='selected mono 2')
plt.xlabel('steps')
plt.xlim(0,timesteps)
plt.legend()
plt.show()

plt.plot(dimer1_distance_arr, label='distance b/w dimer1 and selected mono1')
plt.xlabel('steps')
plt.xlim(0,timesteps)
plt.legend()
plt.show()

plt.plot(dimer2_distance_arr, label='distance b/w dimer2 and selected mono2')
plt.xlabel('steps')
plt.xlim(0,timesteps)
plt.legend()
plt.show()

#print(selected_mono2_arr)
#print(selected_mono1_arr)
'''plt.plot(dist_arr1, color='blue', label='MSD')
plt.xlabel('steps')
plt.ylabel('distance b/w first and last molecule')'''

'''fig = plt.figure(figsize=(20,10))
ax = fig.add_subplot(111, projection='3d')
ax.plot(x,y,z)
ax.scatter(x[selected_mono1],y[selected_mono1],z[selected_mono1])
ax.scatter(x[selected_mono1+1],y[selected_mono1+1],z[selected_mono1+1])
ax.scatter(xd[0],yd[0],zd[0], color='red')
ax.scatter(xd[1],yd[1],zd[1], color='red')
print('dimer 1 = ',xd[0],yd[0],zd[0])
print('mono 1 = ',x[selected_mono1],y[selected_mono1],z[selected_mono1])
print('selected mono -1 = ',x[selected_mono1-1],y[selected_mono1-1],z[selected_mono1-1])
print('dimer 2 = ',xd[1],yd[1],zd[1])
print('mono 2 = ',x[selected_mono1+1],y[selected_mono1+1],z[selected_mono1+1])
print('selected mono +2 = ',x[selected_mono1+2],y[selected_mono1+2],z[selected_mono1+2])
plt.show()'''